% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/2_fit.R
\name{zimnr}
\alias{zimnr}
\title{Fit BNP-ZIMNR}
\usage{
zimnr(dat, n.save, thin, INIT, PRIOR, SETTINGS, adapt.stop = NA,
  delta.fixed = FALSE, poisson.model = FALSE, fixed.norm = FALSE,
  X.mat = NA)
}
\arguments{
\item{dat}{data frame of count data with samples in rows and counts in
columns.  The first two columns of the dataframe should have column names
"subject" and "condition", indicating the grouping factor and sample
condition under which the sample was taken. The model implementation
expects "subject" and "condition" to be ordered numeric labels, starting
with an index of 1 for the first subject.  See the dataset included in the
package for an example.  The remaining columns are compromised of
non-negative integer counts, such as OTU counts in a microbiome study.}

\item{n.save}{number of samples to take.  If \code{thin}=1, the number of
iterations to run the MCMC chain}

\item{thin}{thinning interval}

\item{INIT}{list of parameters used to initialize the MCMC chain with elements:
\itemize{
    \item s.vec; Overdispersion parameters
    \item r.vec; Normalization parameters
    \item c.r.vec; Cluster assignments for normalization parameters, 1-indexed
    \item eta.r.vec; Mean parameters of the first component of the mixture-of-mixtures prior on the normalization parameters
    \item w.r.vec; Mixture weights for the two Gaussian components of the normalization parameters
    \item lambda.r.vec; Indicators for the Gaussian component of the normalization parameters
    \item Delta.mat; Zero inflation indicators
    \item Epsilon.mat; Zero inflation probabilities (Should correspond with Xi.mat)
    \item Xi.mat; Probit of Epsilon.mat
    \item C.xi.mat; Cluster assignments for zero inflation probabilities, 1-indexed
    \item Xi.star.mat; Cluster means for zero inflation probabilities
    \item sigma.2.xi.vec; Variances of Xi.mat mixture distribution
    \item Alpha.mat; Baseline abundances
    \item c.alpha.vec; Cluster assignments for baseline abundances
    \item eta.alpha.vec; Mean parameters of the first component of the mixture-of-mixtures prior on the baseline abundances
    \item w.alpha.vec;  Mixture weights for the two Gaussian components of the baseline abundances
    \item lambda.alpha.vec; Indicators for the Gaussian component of the baseline abundances
    \item Theta.mat; Change in abundance compared to the baseline abundance
    \item C.theta.mat; Cluster assignments for Theta.mat
    \item Theta.star.mat; Mean parameters for Theta.mat mixture
    \item sigma.2.theta.vec; Variance parameters for Theta.mat mixture
}}

\item{PRIOR}{list of hyperparameters with elements:
\itemize{
    \item a.s; mean of s.j prior
    \item b.s.2; variance of s.j prior
    \item a.psi.r; dirichlet concentration parameter for psi.r
    \item a.w.r; theta shape parameter for w.r
    \item b.w.r; theta shape parameter for w.r
    \item u.r.2; normal variance for r.ik mixture
    \item upsilon.r; r.ik mean constraint
    \item b.eta.r.2; normal variance for eta.r
    \item a.psi.alpha; Dirichlet concentration parameter for psi.alpha
    \item a.w.alpha; theta shape parameter for w.alpha
    \item b.w.alpha; theta shape parameter for w.alpha
    \item u.alpha.2; normal variance for alpha mixture
    \item upsilon.alpha; alpha mean constraint
    \item b.eta.alpha.2; normal variance for eta.alpha
    \item rho.theta; Dirichlet-Process concentration parameter for theta
    \item a.theta.star; normal mean for theta.star
    \item b.theta.star.2; normal variance for theta.star
    \item a.sigma.theta; shape parameter for theta variance
    \item b.sigma.theta; scale parameter for theta variance
    \item rho.xi; Dirichlet-Process concentration parameter for xi
    \item a.xi.star; mean for xi.star
    \item b.xi.star.2; variance for xi.star
    \item a.sigma.xi; shape parameter for xi variance
    \item b.sigma.xi; scale parameter for xi variance
}}

\item{SETTINGS}{list of MCMC run settings with elements:
\itemize{
    \item print.mcmc; Print MCMC progress after print.mcmc iterations
    \item s.j.tilde.proposal.sd; Standard deviation for s.j Metropolis proposal
    \item L.r.trunc; Truncation level for r mixture
    \item w.ell.r.proposal.sd; Standard deviation for w.ell.r Metropolis proposal
    \item r.ik.proposal.sd; Standard deviation for r Metropolis proposal
    \item L.alpha.trunc; Truncation level for alpha mixture
    \item w.ell.alpha.proposal.sd; Standard deviation for w.ell.alpha Metropolis proposal
    \item alpha.ij.proposal.sd; Standard deviation for alpha Metropolis proposal
    \item L.theta.trunc; Truncation level for theta mixture
    \item theta.kj.proposal.sd; Standard deviation for theta Metropolis proposal
    \item L.xi.trunc; Truncation level for xi mixture
    \item xi.kj.proposal.sd; Standard deviation for xi Metropolis proposal
}}

\item{adapt.stop}{for the adaptive Metropolis samplers stop adapting
Metropolis proposal SDs after adapt.stop iterations (for example, stop
adapting after some burn-in period).  If set to NA the proposal SDs will
continued to be modified throughout the entire MCMC.}

\item{sanity.checks}{boolean for whether to periodically check of the
parameters are in a consistent state.}
}
\value{
A list whose elements contain samples of the model paramters; one
  sample per row
}
\description{
Used to fit Bayesian nonparametric multivariate NB regression model with
zero-inflation (BNP-ZIMNR). See the accompanying paper in the references for
a more detailed description of the model and its implementation.
}
\examples{
n.save <- 100
thin <- 1
dat <- readRDS(system.file("extdata", "sim_dat_df.rds", package="bnpzimnr"))

# Settings ----------------------------------------------------------------
SETTINGS <- list()
### MCMC
SETTINGS$print.mcmc <- floor(n.save/10)
### s.j
SETTINGS$s.j.tilde.proposal.sd <- 0.1
### r.ik
SETTINGS$L.r.trunc <- 20
SETTINGS$w.ell.r.proposal.sd <- 1
SETTINGS$r.ik.proposal.sd <- 0.075
### alpha.ij
SETTINGS$L.alpha.trunc <- 150
SETTINGS$w.ell.alpha.proposal.sd <- 1
SETTINGS$alpha.ij.proposal.sd <- 0.15
### theta.kj
SETTINGS$L.theta.trunc <- 50
SETTINGS$theta.kj.proposal.sd <- 0.5
### epsilon.kj
SETTINGS$L.xi.trunc <- 50
SETTINGS$xi.kj.proposal.sd <- 0.3

# Setup -------------------------------------------------------------------
Y.mat <- dat[,-c(1:2)]

r.hat.vec <- log(rowSums(Y.mat)/sum(Y.mat))
r.hat.vec <- r.hat.vec - mean(r.hat.vec)

J <- ncol(Y.mat)
N <- nrow(dat)
n <- length(unique(dat$subject))
K <- N/n
R.rep.mat <- matrix(r.hat.vec, ncol=1)[, rep(1, J)]
Mu.ijk.hat.mat.no.off <- (Y.mat)/exp(R.rep.mat)
y.mat.offset <- 1
Mu.ijk.hat.mat <- (Y.mat+y.mat.offset)/exp(R.rep.mat) # Add offset so the log is not -Inf
Alpha.hat.mat <- log(apply(Mu.ijk.hat.mat, 2, function(otu) tapply(otu, factor(dat$subject), FUN=mean)))
Theta.ikj.hat.mat <- log(Y.mat + y.mat.offset) - R.rep.mat - Alpha.hat.mat
Theta.hat.mat <- apply(Theta.ikj.hat.mat, 2, function(theta.j.vec) tapply(theta.j.vec, factor(dat$condition), FUN=mean))

# Prior -------------------------------------------------------------------
PRIOR <- list()
### s.j
PRIOR$a.s <- 0.25
PRIOR$b.s.2 <- 0.25
### r.ik
PRIOR$a.psi.r <- rep(1.0, SETTINGS$L.r.trunc)
PRIOR$a.w.r <- 5
PRIOR$b.w.r <- 5
PRIOR$u.r.2 <- 0.05
PRIOR$upsilon.r <- mean(r.hat.vec)
PRIOR$b.eta.r.2 <- 0.25
### alpha.ij
PRIOR$a.psi.alpha <- rep(1.0, SETTINGS$L.alpha.trunc)
PRIOR$a.w.alpha <- 1
PRIOR$b.w.alpha <- 1
PRIOR$u.alpha.2 <- 2.0
PRIOR$upsilon.alpha <- mean(log(Mu.ijk.hat.mat.no.off[Y.mat!=0]))
PRIOR$b.eta.alpha.2 <- 1.0
### theta.star.kl
PRIOR$rho.theta <- 1
PRIOR$a.theta.star <- 0
PRIOR$b.theta.star.2 <- 10
PRIOR$a.sigma.theta <- 1
PRIOR$b.sigma.theta <- 1
### xi.star.kl
PRIOR$rho.xi <- 1
PRIOR$a.xi.star <- 2
PRIOR$b.xi.star.2 <- 1
PRIOR$a.sigma.xi <- 1
PRIOR$b.sigma.xi <- 1

# Init --------------------------------------------------------------------
INIT <- list()
## s.j
s.tilde.vec <- rnorm(J, log(0.3), 0.01)
INIT$s.vec <- exp(s.tilde.vec)
## r.ik
INIT$r.vec <- r.hat.vec
INIT$c.r.vec <- .bincode(INIT$r.vec, quantile(INIT$r.vec, (0:5)/5), right=TRUE, include.lowest=TRUE)
INIT$d.r.vec <- tabulate(INIT$c.r.vec, nbins=SETTINGS$L.r.trunc)
INIT$eta.r.vec <- rnorm(SETTINGS$L.r.trunc, 0, 1)
INIT$w.r.vec <- rbeta(SETTINGS$L.r.trunc, 1, 1)
INIT$lambda.r.vec <- rbinom(length(INIT$r.vec), size=1, prob=INIT$w.r.vec[INIT$c.r.vec])
INIT$Delta.mat <- as.integer((Y.mat > 0) + 0)
dim(INIT$Delta.mat) <- c(N, J)
A.mat <- fnGetAMat(INIT$Delta.mat, dat$subject)
B.mat <- fnGetBMat(INIT$Delta.mat, dat$condition)
Delta.sum.mat <- fnGetDeltaSumMat(B.mat)
INIT$Epsilon.mat <- apply(Y.mat, 2, function(otu) tapply(otu==0, factor(dat$condition), FUN=mean))
INIT$Epsilon.mat[INIT$Epsilon.mat<0.01] <- 0.05
INIT$Epsilon.mat[INIT$Epsilon.mat>0.99] <- 0.95
INIT$Epsilon.mat <- INIT$Epsilon.mat + runif(length(INIT$Epsilon.mat), -0.01, 0.01)
dim(INIT$Epsilon.mat) <- c(K, J)
INIT$Xi.mat <- qnorm(INIT$Epsilon.mat)
dim(INIT$Xi.mat) <- dim(INIT$Epsilon.mat)
n.xi.bins <- 5
INIT$C.xi.mat <- t(apply(INIT$Xi.mat, 1, function(xi.k.vec) {
    .bincode(xi.k.vec, quantile(xi.k.vec, (0:n.xi.bins)/n.xi.bins, na.rm=TRUE), right=TRUE, include.lowest=TRUE)
}))
INIT$Xi.star.mat <- matrix(0, nrow=K, ncol=SETTINGS$L.xi.trunc)
for(k in 1:K) {
    xi.star.k.init <- tapply(INIT$Xi.mat[k,], INDEX=INIT$C.xi.mat[k,], FUN=mean)
    INIT$Xi.star.mat[k,] <- replace(INIT$Xi.star.mat[k,], 1:length(xi.star.k.init), xi.star.k.init)
}
INIT$sigma.2.xi.vec <- rep(0.25, K)
# alpha.ij
INIT$Alpha.mat <- Alpha.hat.mat
INIT$c.alpha.vec <- .bincode(INIT$Alpha.mat, quantile(INIT$Alpha.mat, (0:5)/5), right=TRUE, include.lowest=TRUE)
INIT$eta.alpha.vec <- rnorm(SETTINGS$L.alpha.trunc, 0, 1)
INIT$w.alpha.vec <- rbeta(SETTINGS$L.alpha.trunc, 1, 1)
INIT$lambda.alpha.vec <- rbinom(length(INIT$Alpha.mat), size=1, prob=INIT$w.alpha.vec[INIT$c.alpha.vec])
INIT$Alpha.mat[A.mat==0] <- NA
INIT$lambda.alpha.vec[A.mat==0] <- NA
INIT$c.alpha.vec[A.mat==0] <- NA
INIT$d.alpha.vec <- tabulate(INIT$c.alpha.vec, nbins=SETTINGS$L.alpha.trunc)
# theta.kj
INIT$Theta.mat <- Theta.hat.mat
INIT$Theta.mat[Delta.sum.mat==0] <- 0
INIT$Theta.mat[B.mat==0] <- NA
n.theta.bins <- 5
INIT$C.theta.mat <- t(apply(INIT$Theta.mat, 1, function(theta.k.vec) {
    .bincode(theta.k.vec, quantile(theta.k.vec, (0:n.theta.bins)/n.theta.bins, na.rm=TRUE), right=TRUE, include.lowest=TRUE)
}))
INIT$C.theta.mat[INIT$Theta.mat==0] <- NA
INIT$Theta.star.mat <- matrix(0, nrow=K, ncol=SETTINGS$L.theta.trunc)
for(k in 1:K) {
    theta.star.k.init <- tapply(INIT$Theta.mat[k,], INDEX=INIT$C.theta.mat[k,], FUN=mean)
    INIT$Theta.star.mat[k,] <- replace(INIT$Theta.star.mat[k,], 1:length(theta.star.k.init), theta.star.k.init)
}
INIT$sigma.2.theta.vec <- rep(0.25, K)

# Model fit ---------------------------------------------------------------
samples <- zimnr(dat, n.save, thin, INIT, PRIOR, SETTINGS)

}
\references{
\emph{A Bayesian Nonparametric Analysis for Zero Inflated
  Multivariate Count Data with Application to Microbiome Study}
}
